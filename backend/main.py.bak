"""
DripMate - AI-Powered Fashion Assistant
Simple FastAPI backend with Gemini AI integration.
"""
from fastapi import FastAPI, HTTPException, Depends, UploadFile, File, Form, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
import tempfile
import shutil
import os
import json
from typing import Optional, List
from datetime import timedelta

from db import get_db, init_db, User, WardrobeItem, FavoriteOutfit
from schemas import (
    ChatRequest, ChatResponse, UserSignup, UserLogin, UserProfile, Token,
    WardrobeItemCreate, WardrobeItemOut, FavoriteCreate, FavoriteOut
)
from llm import get_style_suggestion, get_available_models
from vision import get_outfit_from_image
from auth import (
    get_password_hash, verify_password, create_access_token,
    get_current_user, ACCESS_TOKEN_EXPIRE_MINUTES
)


# Initialize FastAPI
app = FastAPI(
    title="DripMate API",
    description="AI-Powered Fashion Assistant using Gemini",
    version="2.0.0"
)

# CORS for frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173", "http://127.0.0.1:5173"],
    allow_origin_regex=r"^https?://(localhost|127\.0\.0\.1)(:\d+)?$",
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Initialize database on startup
init_db()


@app.get("/")
def root():
    """API info."""
    return {
        "message": "Welcome to DripMate API!",
        "ai_engine": "Google Gemini (with Ollama fallback)",
        "version": "2.0.0",
        "endpoints": {
            "auth": "POST /signup, POST /login",
            "chat": "POST /chat - Get outfit suggestions",
            "upload": "POST /upload-image - Analyze clothing image",
            "wardrobe": "GET/POST /wardrobe",
            "favorites": "GET/POST /favorites"
        }
    }


# === AUTH ROUTES ===

@app.post("/signup", response_model=Token)
def signup(user_data: UserSignup, db: Session = Depends(get_db)):
    """Register a new user."""
    # Check if email already exists
    existing_user = db.query(User).filter(User.email == user_data.email).first()
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )
    
    # Create new user
    hashed_password = get_password_hash(user_data.password)
    new_user = User(
        name=user_data.name,
        email=user_data.email,
        hashed_password=hashed_password,
        gender=user_data.gender,
        age_group=user_data.age_group,
        skin_colour=user_data.skin_colour
    )
    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    
    # Create access token
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": new_user.email},
        expires_delta=access_token_expires
    )
    
    return {"access_token": access_token, "token_type": "bearer"}


@app.post("/login", response_model=Token)
def login(user_data: UserLogin, db: Session = Depends(get_db)):
    """Login user and return JWT token."""
    user = db.query(User).filter(User.email == user_data.email).first()
    if not user or not verify_password(user_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # Create access token
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.email},
        expires_delta=access_token_expires
    )
    
    return {"access_token": access_token, "token_type": "bearer"}


@app.get("/profile", response_model=UserProfile)
def get_profile(current_user: User = Depends(get_current_user)):
    """Get current user profile."""
    return current_user


# === CHAT ROUTES ===

@app.post("/chat", response_model=ChatResponse)
def chat(
    request: ChatRequest,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Get AI-powered outfit suggestions.
    
    Uses user profile (gender, age, skin tone) for personalized suggestions.
    Supports Gemini (default) and Ollama.
    """
    # Use profile data if not provided in request
    gender = request.gender or current_user.gender
    age_group = request.age_group or current_user.age_group
    skin_colour = request.skin_colour or current_user.skin_colour
    
    # Get wardrobe items if requested
    wardrobe = None
    if request.use_wardrobe_only:
        items = db.query(WardrobeItem).filter(WardrobeItem.user_id == current_
            detail="Email already registered"
        )
    
    # Create new user
    hashed_password = get_password_hash(user_data.password)
    new_user = User(
        name=user_data.name,
        email=user_data.email,
        hashed_password=hashed_password,
        gender=user_data.gender,
        age_group=user_data.age_group,
        skin_colour=user_data.skin_colour
    )
    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    
    # Create access token
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": new_user.email},
        expires_delta=access_token_expires
    )
    
    return {"access_token": access_token, "token_type": "bearer"}


@app.post("/login", response_model=Token)
def login(user_data: UserLogin, db: Session = Depends(get_db)):
    """Login user and return JWT token."""
    user = db.query(User).filter(User.email == user_data.email).first()
    if not user or not verify_password(user_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # Create access token
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.email},
        expires_delta=access_token_expires
    )
    
    return {"access_token": access_token, "token_type": "bearer"}


@app.get("/profile", response_model=UserProfile)
def get_profile(current_user: User = Depends(get_current_user)):
    """Get current user profile."""
    return current_user


@app.post("/chat", response_model=ChatResponse)
def chat(request: ChatRequest, db: Session = Depends(get_db)):
    """
    Get AI-powered outfit suggestions.
    
    Provide a base clothing item and get complete outfit ideas.
    Supports Gemini (default) and Ollama.
    """
    # Get wardrobe items if requested
    wardrobe = None
    if request.use_wardrobe_only:
        user = get_or_c with user profile data
    result = get_style_suggestion(
        item=request.item,
        vibe=request.vibe,
        gender=gender,
        age_group=age_group,
        skin_colour=
    
    # Get AI suggestion
    result = get_style_suggestion(
        item=request.item,
        vibe=request.vibe,
        gender=request.gender,
        age_group=request.age_group,
        skin_colour=request.skin_colour,
        num_ideas=request.num_ideas,
        more_details=request.more_details,
        layering_preference=request.layering_preference,
        wardrobe=wardrobe,
        provider=request.ai_provider,
        model_name=request.model,
    )
    
    if not result.get("outfits"):
        error = result.get("error", "Unknown error")
        raise HTTPException(status_code=500, detail=error)
    
    return result,
    current_user: User = Depends(get_current_user)


@app.post("/upload-image")
async def upload_image(
    file: UploadFile = File(...),
    prompt: Optional[str] = Form(None),
    use_wardrobe: bool = Form(False),
    db: Session = Depends(get_db)
):
    """
    Upload a clothing image and get outfit suggestions.
    
    Uses Gemini Vision to analyze the item and suggest complete outfits.
    """
    # Validate file type
    ALLOWED_TYPES = {"image/jpeg", "image/png", "image/webp"}
    if file.content_type not in ALLOWED_TYPES:
        raise HTTPException(
            status_code=400,
            detail=f"Unsupported file type: {file.content_type}"
        )
    
    # Save uploaded file temporarily
    tmpdir = tempfile.mkdtemp(prefix="dripmate_")
    try:
        ext = {
            "image/jpeg": ".jpg",
            "image/png": ".png",
            "image/webp": ".webp"
        }[file.content_type]
        
        tmp_path = os.path.join(tmpdir, f"upload{ext}")
        with open(tmp_path, "wb") as f:
            shutil.copyfileobj(file.file, f)
        
        # Get wardrobe if requested
        wardrobe_items = None
        if uitems = db.query(WardrobeItem).filter(WardrobeItem.user_id == current_
            items = db.query(WardrobeItem).filter(WardrobeItem.user_id == user.id).all()
            wardrobe_items = [
                {
                    "id": item.id,
                    "category": item.category.value,
                    "name": item.name,
                    "color": item.color,
                    "season": item.season,
                }
                for item in items
            ]
        
        # Analyze and get outfit suggestions
        result = get_outfit_from_image(
            tmp_path,
            user_prompt=prompt,
            wardrobe_items=wardrobe_items
        )
        
        return result
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to process image: {e}")
    finally:
        # Cleanup temp files
        try:
            shutil.rmtree(tmpdir)
        except:
            pass


@app.get("/models")
def models():
    """Get available AI models."""
    available = get_available_models()
    return {
        "default_provider": "gemini",
        "providers": {
            "gemini": {
                "name": "Google Gemini",
                "description": "Advanced AI (recommended)",
                "available": available["gemini"]["available"],
                "models": available["gemini"]["models"],
                "default": available["gemini"]["default"],
            },
            "ollama": {
                "name": "Ollama (Local)",
                "description": "Local AI alternative",
                "available": available["ollama"]["available"],
                "models": available["ollama"]["models"],
                "default": available["ollama"]["default"],
            }
        }
    }


# === WARDROBE ROUTES ===

@app.get("/wardrobe", response_model=List[WardrobeItemOut])
def get_wardrobe(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get all wardrobe items for current user."""
    items = db.query(WardrobeItem).filter(WardrobeItem.user_id == current_user.id).all()
    return items


@app.post("/wardrobe", response_model=WardrobeItemOut, status_code=status.HTTP_201_CREATED)
def add_wardrobe_item(
    item: WardrobeItemCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Add a new item to wardrobe."""
    new_item = WardrobeItem(
        user_id=current_user.id,
        category=item.category,
        name=item.name,
        color=item.color,
        season=item.season,
        image_url=item.image_url,
        notes=item.notes
    )
    db.add(new_item)
    db.commit()
    db.refresh(new_item)
    return new_item


@app.delete("/wardrobe/{item_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_wardrobe_item(
    item_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Delete a wardrobe item."""
    item = db.query(WardrobeItem).filter(
        WardrobeItem.id == item_id,
        WardrobeItem.user_id == current_user.id
    ).first()
    
    if not item:
        raise HTTPException(status_code=404, detail="Item not found")
    
    db.delete(item)
    db.commit()
    return None


# === FAVORITES ROUTES ===

@app.get("/favorites", response_model=List[FavoriteOut])
def get_favorites(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get all favorite outfits for current user."""
    favorites = db.query(FavoriteOutfit).filter(
        FavoriteOutfit.user_id == current_user.id
    ).order_by(FavoriteOutfit.created_at.desc()).all()
    return favorites


@app.post("/favorites", response_model=FavoriteOut, status_code=status.HTTP_201_CREATED)
def add_favorite(
    favorite: FavoriteCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Save an outfit as favorite."""
    new_favorite = FavoriteOutfit(
        user_id=current_user.id,
        title=favorite.title,
        source_item=favorite.source_item,
        vibe=favorite.vibe,
        payload=json.dumps(favorite.payload)
    )
    db.add(new_favorite)
    db.commit()
    db.refresh(new_favorite)
    return new_favorite


@app.delete("/favorites/{favorite_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_favorite(
    favorite_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Delete a favorite outfit."""
    favorite = db.query(FavoriteOutfit).filter(
        FavoriteOutfit.id == favorite_id,
        FavoriteOutfit.user_id == current_user.id
    ).first()
    
    if not favorite:
        raise HTTPException(status_code=404, detail="Favorite not found")
    
    db.delete(favorite)
    db.commit()
    return None


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
